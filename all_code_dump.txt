==== File: C:\Users\Fred\Documents\GitHub\universal-reconciliation-service\src\api.js ====

const express = require('express');
const metadataRouter = require('./routes/metadata');
const reconcileRouter = require('./routes/reconcile');
const suggestEntityRouter = require('./routes/suggest-entity');
// ...other routers
const previewRouter = require('./routes/preview');
const extendProposeRouter = require('./routes/extend-propose');
const extendRouter = require('./routes/extend');
const streamChunkRouter = require('./routes/stream-chunk');

const app = express();
app.use(express.json());

// Enable CORS
app.use((req, res, next) => {
  res.set('Access-Control-Allow-Origin', '*');
  next();
});

// Mount routes
app.use('/metadata', metadataRouter);
app.use('/reconcile', reconcileRouter);
app.use('/suggest/entity', suggestEntityRouter);
app.use('/suggest/type', require('./routes/suggest-type'));
app.use('/suggest/property', require('./routes/suggest-property'));
app.use('/preview', previewRouter);
app.use('/extend/propose', extendProposeRouter);
app.use('/extend', extendRouter);
app.use('/stream-chunk', streamChunkRouter);

// Error middleware
app.use((err, req, res, next) => {
  console.error(err);
  res.status(err.status || 500).json({
    status: err.status || 500,
    error: err.name,
    message: err.message,
    timestamp: new Date().toISOString(),
  });
});

module.exports = app;



==== File: C:\Users\Fred\Documents\GitHub\universal-reconciliation-service\src\swagger.js ====

const swaggerJsdoc = require('swagger-jsdoc');
const swaggerUi = require('swagger-ui-express');

const baseUrl = process.env.BASE_URL || 'http://localhost:8888';

const options = {
  definition: {
    openapi: '3.0.3',
    info: {
      title: 'Universal Reconciliation Service API',
      version: '1.0.0',
      description: 'API for reconciliation service using Express and Gemini API',
      contact: {
        name: 'Google',
        email: 'support@example.com',
      },
      license: {
        name: 'MIT',
        url: 'https://opensource.org/licenses/MIT',
      },
    },
    servers: [
      {
        url: baseUrl,
        description: 'Base URL of the API',
      },
    ],
  },
  apis: ['./netlify/functions/routes/*.js'],
};

const swaggerSpec = swaggerJsdoc(options);

function setupSwagger(app) {
  app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));
}

module.exports = setupSwagger;



==== File: C:\Users\Fred\Documents\GitHub\universal-reconciliation-service\src\utils.js ====

const { GoogleGenerativeAI } = require('@google/generative-ai');
const { v4: uuidv4 } = require('uuid');
const path = require('path');
const fs = require('fs');
require('dotenv').config();

const API_KEY = proceupdatess.env.GEMINI_API_KEY;
if (!API_KEY) {
  console.error("GEMINI_API_KEY is not set. Please set the environment variable.");
  process.exit(1);
}
const genAI = new GoogleGenerativeAI(API_KEY);

// Helper function to get the Gemini model response
async function getModelResponse(prompt, isJson, useSearch) {
  try {
    const generationConfig = isJson ? { responseMimeType: "application/json" } : {};
    const tools = useSearch ? [{ google_search: {} }] : undefined;

    const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash-preview-05-20", generationConfig, tools });

    const result = await model.generateContent(prompt);
    const response = await result.response;
    const text = response.text();

    return { text };
  } catch (error) {
    console.error('Gemini API error:', error);
    throw new Error('Failed to get response from Gemini API.');
  }
}

// Helper function to get service metadata
function getServiceMetadata() {
  return {
    name: "Universal Reconciliation Service API",
    identifierSpace: "[http://www.freebase.com/ns/freebase](http://www.freebase.com/ns/freebase)",
    schemaSpace: "[http://www.freebase.com/ns/type.type](http://www.freebase.com/ns/type.type)",
    view: {
      url: "{{id}}"
    },
    defaultTypes: [{
      id: "/common/topic",
      name: "Topic"
    }],
    reconcile: {
      path: "/reconcile",
      serviceUrl: "/.netlify/functions/api"
    },
    suggest: {
      entity: {
        path: "/suggest/entity",
        serviceUrl: "/.netlify/functions/api"
      },
      type: {
        path: "/suggest/type",
        serviceUrl: "/.netlify/functions/api"
      },
      property: {
        path: "/suggest/property",
        serviceUrl: "/.netlify/functions/api"
      }
    },
    preview: {
      path: "/preview",
      serviceUrl: "/.netlify/functions/api"
    },
    extend: {
      propose_properties: {
        path: "/extend/propose",
        serviceUrl: "/.netlify/functions/api"
      },
      serviceUrl: "/.netlify/functions/api"
    }
  };
}

// Helper function to handle reconciliation matching
async function getMatchingResults(queries) {
  const results = {};
  for (const qid in queries) {
    const query = queries[qid];
    const userPrompt = `Reconcile the entity "${query.query}" against entities of type "${query.type}". Provide a list of 5 possible matches in JSON format, each with a 'name', 'id', 'score' (0-100), and 'type' property. The 'score' should reflect the confidence of the match.`;
    const modelResponse = await getModelResponse(userPrompt, true, false);

    const matches = JSON.parse(modelResponse.text);

    results[qid] = {
      result: matches.map(match => ({
        id: match.id || uuidv4(),
        name: match.name,
        score: match.score / 100,
        match: match.score > 70 ? true : false,
        type: [{
          id: match.type,
          name: match.type
        }]
      }))
    };
  }
  return results;
}

// Helper function to handle suggestions
async function getSuggestions(type, prefix) {
  let userPrompt;
  switch (type) {
    case 'entity':
      userPrompt = `Suggest 5 entities related to "${prefix}" in JSON format. Each entity should have a 'name' and 'id'.`;
      break;
    case 'type':
      userPrompt = `Suggest 5 data types related to "${prefix}" in JSON format. Each type should have a 'name' and 'id'.`;
      break;
    case 'property':
      userPrompt = `Suggest 5 properties that start with "${prefix}" in JSON format. Each property should have a 'name' and 'id'.`;
      break;
    default:
      throw new Error(`Invalid suggestion type: ${type}`);
  }

  const modelResponse = await getModelResponse(userPrompt, true, false);
  const suggestions = JSON.parse(modelResponse.text);

  return {
    result: suggestions.map(s => ({
      id: s.id || uuidv4(),
      name: s.name,
      description: s.description || ""
    }))
  };
}

// Helper function to get preview HTML
async function getPreviewHTML(id) {
  const userPrompt = `Generate a short HTML description for an entity with the ID "${id}". Make sure the HTML is well-formed.`;
  const modelResponse = await getModelResponse(userPrompt, true, false);
  return modelResponse.text;
}

// Helper function to get extended properties
async function getExtendedProperties(ids, properties) {
  const data = {};
  for (const id of ids) {
    const userPrompt = `For the entity with ID "${id}", retrieve the values for the following properties: ${properties.map(p => p.id).join(', ')}. Provide the result in a JSON object where keys are the property IDs and values are the corresponding values.`;
    const modelResponse = await getModelResponse(userPrompt, true, false);

    const values = JSON.parse(modelResponse.text);
    data[id] = values;
  }
  return {
    meta: properties.map(p => ({ id: p.id, name: p.name })),
    rows: ids.map(id => ({ id: id, values: properties.map(p => data[id][p.id] ? [{ str: data[id][p.id] }] : []) }))
  };
}


module.exports = {
  getServiceMetadata,
  getModelResponse,
  getMatchingResults,
  getSuggestions,
  getPreviewHTML,
  getExtendedProperties,
};




==== File: C:\Users\Fred\Documents\GitHub\universal-reconciliation-service\src\routes\extend-propose.js ====

/**
 * @swagger
 * /extend-propose:
 *   get:
 *     summary: Example GET endpoint for extend-propose
 *     description: Detailed description for the extend-propose endpoint.
 *     responses:
 *       200:
 *         description: Success response.
 */
const express = require('express');
const router = express.Router();
const { getModelResponse } = require('../utils');
const { v4: uuidv4 } = require('uuid');

// Extend Propose Route
// This endpoint proposes properties for data extension.
router.post('/', async (req, res) => {
  try {
    const type = req.body.type;
    const userPrompt = `Propose 5 properties to extend data for the entity type "${type}". Provide the suggestions in JSON format. Each property should have an 'id' and 'name'.`;
    const modelResponse = await getModelResponse(userPrompt, true, false);

    const properties = JSON.parse(modelResponse.text);

    res.status(200).json({
      properties: properties.map(p => ({
        id: p.id || uuidv4(),
        name: p.name
      }))
    });
  } catch (error) {
    console.error('Extend propose error:', error);
    res.status(500).json({ error: 'Failed to propose properties.' });
  }
});

module.exports = router;



==== File: C:\Users\Fred\Documents\GitHub\universal-reconciliation-service\src\routes\extend.js ====

/**
 * @swagger
 * /extend:
 *   get:
 *     summary: Example GET endpoint for extend
 *     description: Detailed description for the extend endpoint.
 *     responses:
 *       200:
 *         description: Success response.
 */
const express = require('express');
const router = express.Router();
const { getModelResponse } = require('../utils');

// Extend Route
// This endpoint extends data by adding properties to entities.
router.post('/', async (req, res) => {
  try {
    const ids = req.body.ids;
    const properties = req.body.properties;

    if (!ids || !properties || !Array.isArray(ids) || !Array.isArray(properties)) {
      return res.status(400).json({ error: 'Missing or invalid ids or properties.' });
    }

    const data = {};
    for (const id of ids) {
      const userPrompt = `For the entity with ID "${id}", retrieve the values for the following properties: ${properties.map(p => p.id).join(', ')}. Provide the result in a JSON object where keys are the property IDs and values are the corresponding values.`;
      const modelResponse = await getModelResponse(userPrompt, true, false);

      const values = JSON.parse(modelResponse.text);
      data[id] = values;
    }

    res.status(200).json({
      meta: properties.map(p => ({ id: p.id, name: p.name })),
      rows: ids.map(id => ({ id: id, values: properties.map(p => data[id][p.id] ? [{ str: data[id][p.id] }] : []) }))
    });
  } catch (error) {
    console.error('Extend error:', error);
    res.status(500).json({ error: 'Failed to extend data.' });
  }
});

module.exports = router;



==== File: C:\Users\Fred\Documents\GitHub\universal-reconciliation-service\src\routes\metadata.js ====

/**
 * @swagger
 * /metadata:
 *   get:
 *     summary: Example GET endpoint for metadata
 *     description: Detailed description for the metadata endpoint.
 *     responses:
 *       200:
 *         description: Success response.
 */
// src/routes/metadata.js
const express = require('express');
const router = express.Router();

router.get('/', (req, res) => {
  const baseUrl = `${req.protocol}://${req.get('host')}`;
  res.json({
    name: 'Universal Reconciliation Service',
    identifierSpace: 'http://example.com/identifiers',
    schemaSpace: 'http://example.com/schemas',
    defaultTypes: [{ id: '/general', name: 'General Entity' }],
    view: { url: 'http://example.com/view/{{id}}' },
    preview: {
      url: `${baseUrl}/preview?id={{id}}`,
      width: 400,
      height: 200,
    },
    suggest: {
      entity: { service_url: baseUrl, service_path: '/suggest/entity' },
      type: { service_url: baseUrl, service_path: '/suggest/type' },
      property: { service_url: baseUrl, service_path: '/suggest/property' },
    },
    extend: {
      propose_properties: { service_url: baseUrl, service_path: '/extend/propose' },
      property_settings: [
        {
          name: 'maxItems',
          label: 'Maximum number of values',
          type: 'number',
          default: 1,
        },
      ],
    },
  });
});

module.exports = router;



==== File: C:\Users\Fred\Documents\GitHub\universal-reconciliation-service\src\routes\preview.js ====

/**
 * @swagger
 * /preview:
 *   get:
 *     summary: Example GET endpoint for preview
 *     description: Detailed description for the preview endpoint.
 *     responses:
 *       200:
 *         description: Success response.
 */
const express = require('express');
const router = express.Router();
const { getModelResponse } = require('../utils');

// Preview Route
// This endpoint generates a preview of an entity.
router.get('/', async (req, res) => {
  try {
    const id = req.query.id;
    if (!id) {
      return res.status(400).send('Entity ID is required.');
    }

    const userPrompt = `Generate a short HTML description for an entity with the ID "${id}". Make sure the HTML is well-formed.`;
    const modelResponse = await getModelResponse(userPrompt, true, false);

    const htmlContent = modelResponse.text;

    res.status(200).send(htmlContent);
  } catch (error) {
    console.error('Preview error:', error);
    res.status(500).send('Failed to generate preview.');
  }
});

module.exports = router;



==== File: C:\Users\Fred\Documents\GitHub\universal-reconciliation-service\src\routes\stream-chunk.js ====

/**
 * @swagger
 * /stream-chunk:
 *   get:
 *     summary: Example GET endpoint for stream-chunk
 *     description: Detailed description for the stream-chunk endpoint.
 *     responses:
 *       200:
 *         description: Success response.
 */
const express = require('express');
const router = express.Router();
const { getModelResponse } = require('../utils');
const path = require('path');
const fs = require('fs');

// Stream Chunk Route
// This endpoint handles real-time stream chunk matching.
router.post('/', async (req, res) => {
  try {
    const { input, fileName } = req.body;
    if (!input || !fileName) {
      return res.status(400).json({ error: 'Input text and file name are required.' });
    }

    const filePath = path.join(__dirname, '..', '..', 'data', fileName);
    if (!fs.existsSync(filePath)) {
      return res.status(404).json({ error: 'File not found.' });
    }

    const fileContent = fs.readFileSync(filePath, 'utf-8');
    const userPrompt = `Given the input chunk "${input}" and the following data:\n\n---\n${fileContent}\n---\n\nDetermine the best match from the data for the input chunk. Provide a JSON object with 'match' and 'confidence' (0-100) properties. If no match is found, set 'match' to null.`;
    const modelResponse = await getModelResponse(userPrompt, true, false);

    const result = JSON.parse(modelResponse.text);

    res.status(200).json({
      match: result.match,
      confidence: result.confidence / 100
    });
  } catch (error) {
    console.error('Stream chunk error:', error);
    res.status(500).json({ error: 'Failed to process stream chunk.' });
  }
});

module.exports = router;




==== File: C:\Users\Fred\Documents\GitHub\universal-reconciliation-service\src\routes\suggest-property.js ====

/**
 * @swagger
 * /suggest-property:
 *   get:
 *     summary: Example GET endpoint for suggest-property
 *     description: Detailed description for the suggest-property endpoint.
 *     responses:
 *       200:
 *         description: Success response.
 */
const express = require('express');
const router = express.Router();
const { getModelResponse } = require('../utils');
const { v4: uuidv4 } = require('uuid');

// Suggest Property Route
// This endpoint suggests properties based on a query.
router.get('/', async (req, res) => {
  try {
    const query = req.query.prefix;
    const type = req.query.type;
    if (!query) {
      return res.status(400).json({ error: 'Query prefix is required.' });
    }

    let userPrompt;
    if (type) {
      userPrompt = `Suggest 5 properties for a data type named "${type}" that start with "${query}". Provide the suggestions in JSON format, each with a 'name' and 'id'.`;
    } else {
      userPrompt = `Suggest 5 properties that start with "${query}" in JSON format. Each property should have a 'name' and 'id'.`;
    }
    
    const modelResponse = await getModelResponse(userPrompt, true, false);
    const suggestions = JSON.parse(modelResponse.text);

    res.status(200).json({
      result: suggestions.map(s => ({
        id: s.id || uuidv4(),
        name: s.name
      }))
    });
  } catch (error) {
    console.error('Suggest property error:', error);
    res.status(500).json({ error: 'Failed to get property suggestions.' });
  }
});

module.exports = router;



